<!doctype html><html lang=zh-Hant dir=ltr class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-CMU15-445/c08" data-has-hydrated=false><meta charset=UTF-8><meta name=generator content="Docusaurus v3.8.1"><title data-rh=true>CMU 15-445 Indexes & Filters</title><meta data-rh=true name=viewport content="width=device-width, initial-scale=1.0"><meta data-rh=true name=twitter:card content=summary_large_image><meta data-rh=true property=og:image content=https://RulerChen.github.io/RulerChen-Website/img/profile/profile.webp><meta data-rh=true name=twitter:image content=https://RulerChen.github.io/RulerChen-Website/img/profile/profile.webp><meta data-rh=true property=og:url content=https://RulerChen.github.io/RulerChen-Website/docs/CMU15-445/c08/><meta data-rh=true property=og:locale content=zh_Hant><meta data-rh=true property=og:locale:alternate content=en><meta data-rh=true name=docusaurus_locale content=zh-Hant><meta data-rh=true name=docsearch:language content=zh-Hant><meta data-rh=true name=docusaurus_version content=current><meta data-rh=true name=docusaurus_tag content=docs-default-current><meta data-rh=true name=docsearch:version content=current><meta data-rh=true name=docsearch:docusaurus_tag content=docs-default-current><meta data-rh=true property=og:title content="Indexes & Filters | RulerChen"><meta data-rh=true name=description content="CMU15-445/645 Indexes & Filters"><meta data-rh=true property=og:description content="CMU15-445/645 Indexes & Filters"><meta data-rh=true name=keywords content="CMU15-445/645,Indexes & Filters,CMU15-445/645 筆記"><link data-rh=true rel=icon href=/RulerChen-Website/img/profile/profile.webp><link data-rh=true rel=canonical href=https://RulerChen.github.io/RulerChen-Website/docs/CMU15-445/c08/><link data-rh=true rel=alternate href=https://RulerChen.github.io/RulerChen-Website/docs/CMU15-445/c08/ hreflang=zh-Hant><link data-rh=true rel=alternate href=https://RulerChen.github.io/RulerChen-Website/en/docs/CMU15-445/c08/ hreflang=en><link data-rh=true rel=alternate href=https://RulerChen.github.io/RulerChen-Website/docs/CMU15-445/c08/ hreflang=x-default><link data-rh=true rel=preconnect href=https://GSV9DQB5UM-dsn.algolia.net crossorigin=anonymous><script data-rh=true type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://RulerChen.github.io/RulerChen-Website/docs/CMU15-445/","name":"CMU 15-445/645","position":1},{"@type":"ListItem","item":"https://RulerChen.github.io/RulerChen-Website/docs/CMU15-445/c08","name":"Indexes & Filters","position":2}]}</script><link rel=alternate type=application/rss+xml href=/RulerChen-Website/blog/rss.xml title="RulerChen RSS Feed"><link rel=alternate type=application/atom+xml href=/RulerChen-Website/blog/atom.xml title="RulerChen Atom Feed"><link rel=preconnect href=https://www.google-analytics.com><link rel=preconnect href=https://www.googletagmanager.com><script async src="https://www.googletagmanager.com/gtag/js?id=G-8BEHDPLQMG"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-8BEHDPLQMG",{anonymize_ip:!0})</script><link rel=search type=application/opensearchdescription+xml title=RulerChen href=/RulerChen-Website/opensearch.xml><meta name=google-site-verification content=QrdRbPEcOsJJ_kfRVewqfwR6GjPcRf0UVgRb85I-5fc><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css type=text/css integrity=sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM crossorigin=anonymous><link rel=stylesheet href=/RulerChen-Website/assets/css/styles.045d425e.css><script src=/RulerChen-Website/assets/js/runtime~main.dc20b287.js defer></script><script src=/RulerChen-Website/assets/js/main.a892592f.js defer></script><body class=navigation-with-keyboard><svg xmlns=http://www.w3.org/2000/svg style="display: none;"><defs>
<symbol id=theme-svg-external-link viewBox="0 0 24 24"><path fill=currentColor d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="dark",e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{for(var[t,e]of new URLSearchParams(window.location.search).entries())if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id=__docusaurus><link rel=preload as=image href=/RulerChen-Website/img/profile/profile.webp><div role=region aria-label=跳至主要内容><a class=skipToContent_fXgn href=#__docusaurus_skipToContent_fallback>跳至主要内容</a></div><nav aria-label=主導航 class="theme-layout-navbar navbar navbar--fixed-top"><div class=navbar__inner><div class="theme-layout-navbar-left navbar__items"><button aria-label=切換導覽列 aria-expanded=false class="navbar__toggle clean-btn" type=button><svg width=30 height=30 viewBox="0 0 30 30" aria-hidden=true><path stroke=currentColor stroke-linecap=round stroke-miterlimit=10 stroke-width=2 d="M4 7h22M4 15h22M4 23h22"/></svg></button><a class=navbar__brand href=/RulerChen-Website/><div class=navbar__logo><img src=/RulerChen-Website/img/profile/profile.webp alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src=/RulerChen-Website/img/profile/profile.webp alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">RulerChen</b></a><a aria-current=page class="navbar__item navbar__link navbar__link--active" href=/RulerChen-Website/docs/intro/>Notes</a><a class="navbar__item navbar__link" href=/RulerChen-Website/blog/>Blog</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href=# aria-haspopup=true aria-expanded=false role=button class=navbar__link><svg viewBox="0 0 24 24" width=20 height=20 aria-hidden=true class=iconLanguage_nlXk><path fill=currentColor d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"/></svg>繁體中文</a><ul class=dropdown__menu><li><a href=/RulerChen-Website/docs/CMU15-445/c08/ target=_self rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang=zh-Hant>繁體中文</a><li><a href=/RulerChen-Website/en/docs/CMU15-445/c08/ target=_self rel="noopener noreferrer" class=dropdown__link lang=en>English</a></ul></div><div class=navbarSearchContainer_Bca1><button type=button class="DocSearch DocSearch-Button" aria-label="搜尋 (Command+K)"><span class=DocSearch-Button-Container><svg width=20 height=20 class=DocSearch-Search-Icon viewBox="0 0 20 20" aria-hidden=true><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke=currentColor fill=none fill-rule=evenodd stroke-linecap=round stroke-linejoin=round /></svg><span class=DocSearch-Button-Placeholder>搜尋</span></span><span class=DocSearch-Button-Keys></span></button></div></div></div><div role=presentation class=navbar-sidebar__backdrop></div></nav><div id=__docusaurus_skipToContent_fallback class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class=docsWrapper_hBAB><button aria-label=回到頂部 class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type=button></button><div class=docRoot_UBD9><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class=sidebarViewport_aRkj><div class=sidebar_njMd><nav aria-label=文件側邊欄 class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class=menu__link href=/RulerChen-Website/docs/intro/>Roadmap</a><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist menu__link--active" href=/RulerChen-Website/docs/CMU15-445/>CMU 15-445/645</a><button aria-label="收起側邊欄分類 'CMU 15-445/645'" aria-expanded=true type=button class="clean-btn menu__caret"></button></div><ul class=menu__list><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c01/>Relational Model & Algebra</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c02/>Modern SQL</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c03/>Database Storage</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c05/>Storage Models & Compression</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c06/>Memory & Disk I/O Management</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c07/>Hash Tables</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current=page tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c08/>Indexes & Filters</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c09/>Index Concurrency Control</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c11/>Sorting & Aggregations Algorithms</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c12/>Joins Algorithms</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c13/>Query Execution</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c15/>Query Planning & Optimization</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c16/>Concurrency Control Theory</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c17/>Two-Phase Locking Concurrency Control</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c18/>Timestamp Ordering Concurrency Control</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c19/>Multi-Version Concurrency Control</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c20/>Database Logging</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c21/>Database Recovery</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c22/>Introduction to Distributed Databases</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c23/>Distributed OLTP Database Systems</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/c24/>Distributed OLAP Database Systems</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/p0/>P0 - C++ Primer</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/p1/>P1 - Buffer Pool Manager</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/p2/>P2 - B+ Tree</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/p3/>P3 - Query Execution</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/RulerChen-Website/docs/CMU15-445/p4/>P4 - Concurrency Control</a></ul><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/RulerChen-Website/docs/Security/>Security</a><button aria-label="展開側邊欄分類 'Security'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div></ul></nav></div></div></aside><main class=docMainContainer_TBSr><div class="container padding-top--md padding-bottom--lg"><div class=row><div class="col docItemCol_z5aJ"><div class=docItemContainer_c0TR><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label=頁面路徑><ul class=breadcrumbs><li class=breadcrumbs__item><a aria-label=主頁面 class=breadcrumbs__link href=/RulerChen-Website/><svg viewBox="0 0 24 24" class=breadcrumbHomeIcon_YNFT><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill=currentColor /></svg></a><li class=breadcrumbs__item><a class=breadcrumbs__link href=/RulerChen-Website/docs/CMU15-445/><span>CMU 15-445/645</span></a><li class="breadcrumbs__item breadcrumbs__item--active"><span class=breadcrumbs__link>Indexes & Filters</span></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type=button class="clean-btn tocCollapsibleButton_TO0P">本頁導覽</button></div><div class="theme-doc-markdown markdown"><header><h1>Indexes & Filters</h1></header>
<p>Index 跟 Filter 是 DBMS 中非常重要的概念，能夠幫助我們更快地查找資料。</p>
<p>Index 用於快速查詢資料在表中的實際位置，像是 B+Tree Index、Hash Index。
Filter 則是用於快速判斷某個資料是否可能存在集合中，像是 Bloom Filter。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=b-tree>B-Tree<a href=#b-tree class=hash-link aria-label=B-Tree的直接連結 title=B-Tree的直接連結>​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=b-tree-family>B-Tree Family<a href=#b-tree-family class=hash-link aria-label="B-Tree Family的直接連結" title="B-Tree Family的直接連結">​</a></h3>
<p>B-Tree 中的 B 通常代表 Balanced，而 B-Tree 的變種有很多，例如 :</p>
<ul>
<li>B-Tree</li>
<li>B+Tree</li>
<li>B* Tree</li>
<li><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msup><mi>B</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>k</mi></mrow></msup></mrow><annotation encoding=application/x-tex>B^{link}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:0.8491em></span><span class=mord><span class="mord mathnormal" style=margin-right:0.05017em>B</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:0.8491em><span style=top:-3.063em;margin-right:0.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style=margin-right:0.01968em>l</span><span class="mord mathnormal mtight" style=margin-right:0.03148em>ink</span></span></span></span></span></span></span></span></span></span></span></span> Tree</li>
</ul>
<p>其中最常見的是 B+Tree，各個 DBMS 也會使用不同的 B-Tree 家族的變種，如 PostgreSQL 使用了 Lehman and Yao's high-concurrency B-tree management algorithm。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=btree>B+Tree<a href=#btree class=hash-link aria-label=B+Tree的直接連結 title=B+Tree的直接連結>​</a></h3>
<p>B+Tree 是一種 self-balancing 的多路搜尋樹，能在 search、insert、delete 操作中保證 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>O</mi><mo stretchy=false>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>O(\log n)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-0.25em></span><span class="mord mathnormal" style=margin-right:0.02778em>O</span><span class=mopen>(</span><span class=mop>lo<span style=margin-right:0.01389em>g</span></span><span class=mspace style=margin-right:0.1667em></span><span class="mord mathnormal">n</span><span class=mclose>)</span></span></span></span> 的時間複雜度，並且在 sequential access（如 range scan）時能有效率地達成 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>O</mi><mo stretchy=false>(</mo><mi>k</mi><mo>+</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>O(k + \log n)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-0.25em></span><span class="mord mathnormal" style=margin-right:0.02778em>O</span><span class=mopen>(</span><span class="mord mathnormal" style=margin-right:0.03148em>k</span><span class=mspace style=margin-right:0.2222em></span><span class=mbin>+</span><span class=mspace style=margin-right:0.2222em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-0.25em></span><span class=mop>lo<span style=margin-right:0.01389em>g</span></span><span class=mspace style=margin-right:0.1667em></span><span class="mord mathnormal">n</span><span class=mclose>)</span></span></span></span> 的複雜度，其中 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>k</mi></mrow><annotation encoding=application/x-tex>k</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:0.6944em></span><span class="mord mathnormal" style=margin-right:0.03148em>k</span></span></span></span> 為輸出資料量。</p>
<figure class=image-modal-container><img src=/RulerChen-Website/img/cmu15-445/c08/image.webp alt="" width=100% class=image-modal-thumbnail style=cursor:pointer loading=lazy><figcaption class=image-modal-caption>B+ Tree Example</figcaption></figure>
<p>M-way B+Tree 的特點有 :</p>
<ul>
<li>每個節點最多儲存 M 個 key，並且有 M+1 個 children</li>
<li>每個 leaf node 的深度都相同 (perfectly balanced)</li>
<li>除了 root node 以外，每個節點都至少要有 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>M</mi><mi mathvariant=normal>/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo>≤</mo><mi>k</mi><mi>e</mi><mi>y</mi><mi>s</mi><mo>≤</mo><mi>M</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=application/x-tex>M / 2 - 1 \leq keys \leq M - 1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-0.25em></span><span class="mord mathnormal" style=margin-right:0.10903em>M</span><span class=mord>/2</span><span class=mspace style=margin-right:0.2222em></span><span class=mbin>−</span><span class=mspace style=margin-right:0.2222em></span></span><span class=base><span class=strut style=height:0.7804em;vertical-align:-0.136em></span><span class=mord>1</span><span class=mspace style=margin-right:0.2778em></span><span class=mrel>≤</span><span class=mspace style=margin-right:0.2778em></span></span><span class=base><span class=strut style=height:0.8889em;vertical-align:-0.1944em></span><span class="mord mathnormal" style=margin-right:0.03148em>k</span><span class="mord mathnormal">eys</span><span class=mspace style=margin-right:0.2778em></span><span class=mrel>≤</span><span class=mspace style=margin-right:0.2778em></span></span><span class=base><span class=strut style=height:0.7667em;vertical-align:-0.0833em></span><span class="mord mathnormal" style=margin-right:0.10903em>M</span><span class=mspace style=margin-right:0.2222em></span><span class=mbin>−</span><span class=mspace style=margin-right:0.2222em></span></span><span class=base><span class=strut style=height:0.6444em></span><span class=mord>1</span></span></span></span> 個 key (半滿)</li>
<li>leaf node 會透過 doubly linked list 連接，提高 sequential access 的效率</li>
</ul>
<figure class=image-modal-container><img src=/RulerChen-Website/img/cmu15-445/c08/image-1.webp alt="" width=100% class=image-modal-thumbnail style=cursor:pointer loading=lazy><figcaption class=image-modal-caption>B+ Tree Leaf Node</figcaption></figure>
<p>每個 node 中都包含了一個經過排序的 key / value 陣列，其中 key 就是 index 的值，而 value 則會根據是 inner node 或 leaf node 而有所不同。</p>
<p>其中 inner node 的值就是指向下一個節點的指標，而 leaf node 的值則有兩種不同的實作方式 :</p>
<ul>
<li>Record IDs : 直接儲存指向 tuple 的指標</li>
<li>Tuple Data : 直接儲存 tuple 的資料，但對於 secondary index 來說，這樣會造成重複儲存</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=btree-operations>B+Tree Operations<a href=#btree-operations class=hash-link aria-label="B+Tree Operations的直接連結" title="B+Tree Operations的直接連結">​</a></h3>
<p>有關 B+Tree 的操作，可以參考 <a href=https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html target=_blank rel="noopener noreferrer">這個網站</a>。</p>
<p>我們也會在 <a href=/RulerChen-Website/docs/CMU15-445/p2/>Project #2</a> 中實作 B+Tree 的各種操作。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=btree-vs-b-tree>B+Tree vs B-Tree<a href=#btree-vs-b-tree class=hash-link aria-label="B+Tree vs B-Tree的直接連結" title="B+Tree vs B-Tree的直接連結">​</a></h3>
<p>B-Tree 的資料分布在 internal 和 leaf node，而 B+Tree 所有資料都存在葉節點，internal node 只存 key，這導致 B+Tree 的高度通常更低，搜尋起來會更穩定。</p>
<p>除此之外，B+Tree 的葉節點有鏈結，所以在 sequential 或 range query 上效率遠高於 B-Tree。
雖然兩者的 search、insert、delete 複雜度都是 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>O</mi><mo stretchy=false>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>O(\log n)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-0.25em></span><span class="mord mathnormal" style=margin-right:0.02778em>O</span><span class=mopen>(</span><span class=mop>lo<span style=margin-right:0.01389em>g</span></span><span class=mspace style=margin-right:0.1667em></span><span class="mord mathnormal">n</span><span class=mclose>)</span></span></span></span>，但因為 B+Tree 更適合硬碟存取，所以在實際應用中會比 B-Tree 更有效率。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=composite-indexes>Composite Indexes<a href=#composite-indexes class=hash-link aria-label="Composite Indexes的直接連結" title="Composite Indexes的直接連結">​</a></h3>
<p>B+Tree 可以支援 composite indexes，也就是可以在一個 index 中儲存多個 key。</p>
<div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style=--prism-color:#F8F8F2;--prism-background-color:#282A36><div class=codeBlockContent_QJqH><pre tabindex=0 class="prism-code language-sql codeBlock_bY9V thin-scrollbar" style=color:#F8F8F2;background-color:#282A36><code class=codeBlockLines_e6Vv><span class=token-line style=color:#F8F8F2><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">CREATE</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">INDEX</span><span class="token plain"> idx </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">ON</span><span class="token plain"> table_name </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">key1</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> key2</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> key3</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><br></span></code></pre></div></div>
<p>這樣的 index 可以用來加速查詢，並且可以支援多個 key 的查詢，但必須遵守最左匹配規則 (leftmost indexing rule)，也就是說，查詢時必須從左到右使用 index 中的 key。</p>
<div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style=--prism-color:#F8F8F2;--prism-background-color:#282A36><div class=codeBlockContent_QJqH><pre tabindex=0 class="prism-code language-sql codeBlock_bY9V thin-scrollbar" style=color:#F8F8F2;background-color:#282A36><code class=codeBlockLines_e6Vv><span class=token-line style=color:#F8F8F2><span class="token comment" style="color:rgb(98, 114, 164)">-- ok</span><span class="token plain"></span><br></span><span class=token-line style=color:#F8F8F2><span class="token plain"></span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">SELECT</span><span class="token plain"> </span><span class="token operator">*</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">FROM</span><span class="token plain"> table_name </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">WHERE</span><span class="token plain"> key1 </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">1</span><span class="token plain"> </span><span class="token operator">AND</span><span class="token plain"> key2 </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">2</span><span class="token plain"> </span><span class="token operator">AND</span><span class="token plain"> key3 </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">3</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class=token-line style=color:#F8F8F2><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#F8F8F2><span class="token plain"></span><span class="token comment" style="color:rgb(98, 114, 164)">-- ok</span><span class="token plain"></span><br></span><span class=token-line style=color:#F8F8F2><span class="token plain"></span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">SELECT</span><span class="token plain"> </span><span class="token operator">*</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">FROM</span><span class="token plain"> table_name </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">WHERE</span><span class="token plain"> key1 </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">1</span><span class="token plain"> </span><span class="token operator">AND</span><span class="token plain"> key2 </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">2</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class=token-line style=color:#F8F8F2><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#F8F8F2><span class="token plain"></span><span class="token comment" style="color:rgb(98, 114, 164)">-- ok</span><span class="token plain"></span><br></span><span class=token-line style=color:#F8F8F2><span class="token plain"></span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">SELECT</span><span class="token plain"> </span><span class="token operator">*</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">FROM</span><span class="token plain"> table_name </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">WHERE</span><span class="token plain"> key1 </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">1</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class=token-line style=color:#F8F8F2><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#F8F8F2><span class="token plain"></span><span class="token comment" style="color:rgb(98, 114, 164)">-- only key1 index is used</span><span class="token plain"></span><br></span><span class=token-line style=color:#F8F8F2><span class="token plain"></span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">SELECT</span><span class="token plain"> </span><span class="token operator">*</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">FROM</span><span class="token plain"> table_name </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">WHERE</span><span class="token plain"> key1 </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">1</span><span class="token plain"> </span><span class="token operator">AND</span><span class="token plain"> key3 </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">3</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class=token-line style=color:#F8F8F2><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#F8F8F2><span class="token plain"></span><span class="token comment" style="color:rgb(98, 114, 164)">-- not ok</span><span class="token plain"></span><br></span><span class=token-line style=color:#F8F8F2><span class="token plain"></span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">SELECT</span><span class="token plain"> </span><span class="token operator">*</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">FROM</span><span class="token plain"> table_name </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">WHERE</span><span class="token plain"> key2 </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">2</span><span class="token plain"> </span><span class="token operator">AND</span><span class="token plain"> key3 </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">3</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=duplicate-keys>Duplicate Keys<a href=#duplicate-keys class=hash-link aria-label="Duplicate Keys的直接連結" title="Duplicate Keys的直接連結">​</a></h3>
<p>有兩種常見的方式來處理 duplicate keys :</p>
<ul>
<li>Append Record ID : 把唯一的 Record ID 附加在 key 後面，這樣可以保證每個 key 都是唯一的，但會增加 index 的大小。</li>
<li>Overflow Leaf Nodes : 允許節點溢出來儲存 duplicate keys。</li>
</ul>
<figure class=image-modal-container><img src=/RulerChen-Website/img/cmu15-445/c08/image-2.webp alt="" width=100% class=image-modal-thumbnail style=cursor:pointer loading=lazy><figcaption class=image-modal-caption>B+ Tree Append Record ID</figcaption></figure>
<figure class=image-modal-container><img src=/RulerChen-Website/img/cmu15-445/c08/image-3.webp alt="" width=100% class=image-modal-thumbnail style=cursor:pointer loading=lazy><figcaption class=image-modal-caption>B+ Tree Overflow Leaf Nodes</figcaption></figure>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=clustered-indexes>Clustered Indexes<a href=#clustered-indexes class=hash-link aria-label="Clustered Indexes的直接連結" title="Clustered Indexes的直接連結">​</a></h3>
<p>Clustered Index 是一種資料實體的排序方式，會讓資料表的資料依照某個欄位排序儲存，而不是隨機或插入順序。
這對於範圍查詢非常有用，因為可以直接從硬碟上讀取連續的資料頁面。</p>
<figure class=image-modal-container><img src=/RulerChen-Website/img/cmu15-445/c08/image-8.webp alt="" width=100% class=image-modal-thumbnail style=cursor:pointer loading=lazy><figcaption class=image-modal-caption>B+ Tree Clustered Index</figcaption></figure>
<p>在 PostgreSQL 中，我們可以使用以下的 SQL 指令來做一次 one-time 的 clustering :</p>
<div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style=--prism-color:#F8F8F2;--prism-background-color:#282A36><div class=codeBlockContent_QJqH><pre tabindex=0 class="prism-code language-sql codeBlock_bY9V thin-scrollbar" style=color:#F8F8F2;background-color:#282A36><code class=codeBlockLines_e6Vv><span class=token-line style=color:#F8F8F2><span class="token plain">CLUSTER table_name </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">USING</span><span class="token plain"> index_name</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=index-scan-page-sorting>Index Scan Page Sorting<a href=#index-scan-page-sorting class=hash-link aria-label="Index Scan Page Sorting的直接連結" title="Index Scan Page Sorting的直接連結">​</a></h3>
<p>由於直接從 unclustered index 中取得資料非常沒效率，因此 DBMS 可以先把要用的 tuple 都找出來，然後根據 page_id 做排序，這樣就可以減少硬碟的隨機存取。</p>
<figure class=image-modal-container><img src=/RulerChen-Website/img/cmu15-445/c08/image-4.webp alt="" width=100% class=image-modal-thumbnail style=cursor:pointer loading=lazy><figcaption class=image-modal-caption>B+ Tree Index Scan Page Sorting</figcaption></figure>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=btree-design-choices>B+Tree Design Choices<a href=#btree-design-choices class=hash-link aria-label="B+Tree Design Choices的直接連結" title="B+Tree Design Choices的直接連結">​</a></h2>
<p>B+Tree 看似是一個單純的資料結構，但實際上有很多設計上的選擇會影響它的效能。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=node-size>Node Size<a href=#node-size class=hash-link aria-label="Node Size的直接連結" title="Node Size的直接連結">​</a></h3>
<p>一般來說，硬碟 I/O 包含了 seek time 跟 transfer time，對於 HDD 來說，seek time 通常是主要的瓶頸，因此我們希望每次讀取的資料量越多越好，而對於 In-Memory 來說，cache miss 才是主要的瓶頸，因此我們希望每次讀取的資料量剛好能塞進 cache line。</p>
<p>也因此，不同的儲存媒介會有不同的最佳 node size :</p>
<ul>
<li>HDD : 1MB</li>
<li>SSD : 10KB</li>
<li>In-Memory : 512B</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=merge-threshold>Merge Threshold<a href=#merge-threshold class=hash-link aria-label="Merge Threshold的直接連結" title="Merge Threshold的直接連結">​</a></h3>
<p>由於 B+Tree 的合併開銷很大，所以有些 DBMS 並不會在每次插入時都合併，而是會由其他的 process 來定期處理合併。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=variable-length-keys>Variable Length Keys<a href=#variable-length-keys class=hash-link aria-label="Variable Length Keys的直接連結" title="Variable Length Keys的直接連結">​</a></h3>
<p>處理不定長度的 key 有以下幾種方式 :</p>
<ul>
<li>Pointers : 儲存一個指標指向 tuple</li>
<li>Variable-Length Nodes : 允許可變長度，但需要精細的記憶體管理</li>
<li>Padding : 將 key 填滿到固定長度</li>
<li>Key Map / Indirection : 使用一個固定長度的 key map 來指向實際的 key / value，有點類似 slotted page</li>
</ul>
<p>如果一個 key 就比 node 還大，那就需要再把它存到 overflow page 中來處理。
在 PostgreSQL 中，這個 overflow page 被稱為 TOAST (The Oversized-Attribute Storage Technique)，當有超過 2KB 的資料時，就會切成多塊並存到獨立的 TOAST 表中。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=intra-node-search>Intra-Node Search<a href=#intra-node-search class=hash-link aria-label="Intra-Node Search的直接連結" title="Intra-Node Search的直接連結">​</a></h3>
<p>在節點內搜索有三種方式 :</p>
<ul>
<li>Linear : 遍歷整個節點。線性掃描對 CPU cache 友善，並且能搭配 SIMD 指令來進行加速，因此即使 B+Tree 的節點內是排序過的，線性掃描仍然是常見的選擇。</li>
<li>Binary : 二分搜索，演算法複雜度比較低，但對 CPU cache 不友善</li>
<li>Interpolation : 用 key 的分布來估計位置，舉例來說，如果 key 是 1 到 1000 之間的數字，且我們要找 500，那就可以直接跳到中間的位置。</li>
</ul>
<div class="theme-admonition theme-admonition-note admonition_xJq3 alert alert--secondary"><div class=admonitionHeading_Gvgb><span class=admonitionIcon_Rf37><svg viewBox="0 0 14 16"><path fill-rule=evenodd d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"/></svg></span>備註</div><div class=admonitionContent_BuS1><p>SIMD (Single Instruction, Multiple Data) 是一種平行運算的技術，可以讓 CPU 在同一個指令週期內對多個資料進行相同的操作，與之相對的是 SISD (Single Instruction, Single Data)，也就是傳統的單一資料流處理方式。<p>在現代的 CPU 中，除了有 eax 這種通用的暫存器外，還有一種叫做向量暫存器 (vector register) 的東西，常見的有 XMM (128-bit)、YMM (256-bit)、ZMM (512-bit) 等等，這些向量暫存器可以一次儲存多個資料。
而 SIMD 指令集就是用來操作這些向量暫存器的，它可以讓我們在一個指令週期內對多個資料進行相同的運算，如 <code>_mm_add_epi32</code> 可以同時對向量暫存器中的四個 32-bit 整數進行加法運算，<code>_mm_cmpgt_epi32</code> 可以同時比較向量暫存器中的四個 32-bit 整數。</div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=b-tree-optimizations>B+ Tree Optimizations<a href=#b-tree-optimizations class=hash-link aria-label="B+ Tree Optimizations的直接連結" title="B+ Tree Optimizations的直接連結">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=prefix-compression>Prefix Compression<a href=#prefix-compression class=hash-link aria-label="Prefix Compression的直接連結" title="Prefix Compression的直接連結">​</a></h3>
<p>同一個 node 常常有相同的 key，我們可以透過 prefix 來減少儲存空間。</p>
<figure class=image-modal-container><img src=/RulerChen-Website/img/cmu15-445/c08/image-5.webp alt="" width=100% class=image-modal-thumbnail style=cursor:pointer loading=lazy><figcaption class=image-modal-caption>B+ Tree Prefix</figcaption></figure>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=deduplication>Deduplication<a href=#deduplication class=hash-link aria-label=Deduplication的直接連結 title=Deduplication的直接連結>​</a></h3>
<p>可以將重複的 key 合併。</p>
<figure class=image-modal-container><img src=/RulerChen-Website/img/cmu15-445/c08/image-6.webp alt="" width=100% class=image-modal-thumbnail style=cursor:pointer loading=lazy><figcaption class=image-modal-caption>B+ Tree Deduplication</figcaption></figure>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=suffix-truncation>Suffix Truncation<a href=#suffix-truncation class=hash-link aria-label="Suffix Truncation的直接連結" title="Suffix Truncation的直接連結">​</a></h3>
<p>在 inner node 中， key 只是用來決定要往左還是往右走，因此只需要儲存可供辨識的部分。
例如 key 是 abcdefgh，我們可以只儲存 abc。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=pointer-swizzling>Pointer Swizzling<a href=#pointer-swizzling class=hash-link aria-label="Pointer Swizzling的直接連結" title="Pointer Swizzling的直接連結">​</a></h3>
<p>在 DBMS 中，如果我們要查詢一個 page 的位置，通常要帶著 page_id 來查詢 page table，但如果這個 page 已經固定在 buffer pool 中，我們就可以使用原始指標而不需要再訪問 page table。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=bulk-insert>Bulk Insert<a href=#bulk-insert class=hash-link aria-label="Bulk Insert的直接連結" title="Bulk Insert的直接連結">​</a></h3>
<p>最快建立 B+Tree 的方法是將 key 先排好序，再從下往上建立 B+Tree，適合在大量資料匯入時使用。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=write-optimized-b-tree>Write-Optimized B+ Tree<a href=#write-optimized-b-tree class=hash-link aria-label="Write-Optimized B+ Tree的直接連結" title="Write-Optimized B+ Tree的直接連結">​</a></h3>
<p>因為分裂和合併節點在 B+Tree 中非常耗時，因此有些 B-Tree 的變體會延遲這些行為，如 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>B</mi><mi>ϵ</mi></mrow><annotation encoding=application/x-tex>B\epsilon</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:0.6833em></span><span class="mord mathnormal" style=margin-right:0.05017em>B</span><span class="mord mathnormal">ϵ</span></span></span></span>-Tree，這種樹會將變動儲存在 log 檔並慢慢往下傳遞。</p>
<figure class=image-modal-container><img src=/RulerChen-Website/img/cmu15-445/c08/image-7.webp alt="" width=100% class=image-modal-thumbnail style=cursor:pointer loading=lazy><figcaption class=image-modal-caption>B-epsilon tree</figcaption></figure>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=bloom-filter>Bloom Filter<a href=#bloom-filter class=hash-link aria-label="Bloom Filter的直接連結" title="Bloom Filter的直接連結">​</a></h2>
<p>Bloom Filter 是一種機率型的資料結構，提供了 insert 跟 lookup 的功能 (沒有 delete)，可以幫助我們快速的判斷某個資料是否存在於集合中。
有可能會產生 false positive (沒有這個資料，但回傳有)，但不會產生 false negative (有這個資料，但回傳沒有)。</p>
<p>操作方法如下：</p>
<ol>
<li>初始化一個位元陣列 (bitmap)，大小為 m 位元。</li>
<li>選擇 k 個 hash function，這些 hash function 可以將資料映射到 0 到 m-1 的範圍內。</li>
<li>當插入一個資料時，使用 k 個 hash function 計算出 k 個位置，將這些位置的位元設為 1。</li>
<li>當查找一個資料時，使用 k 個 hash function，檢查 k 個位置是否都是 1，如果是，則可能存在，如果有任何一個位置是 0，則一定不存在。</li>
</ol>
<figure class=image-modal-container><img src=/RulerChen-Website/img/cmu15-445/c08/image-17.webp alt="" width=100% class=image-modal-thumbnail style=cursor:pointer loading=lazy><figcaption class=image-modal-caption>Bloom Filter</figcaption></figure>
<p>除了比較正統的 Bloom Filter 之外，還有一些變體 :</p>
<ul>
<li>Counting Bloom Filter : 使用計數器來代替位元陣列，這樣可以支援刪除操作。</li>
<li>Cuckoo Filter : 使用 cuckoo hashing 跟 fingerprint 技術來減少 false positive 的機率，並且支援刪除操作。</li>
<li>Succinct Range Filter : 一種不可修改的 Bloom Filter，使用位元陣列來表示一個範圍內的值是否存在。</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=skip-list>Skip List<a href=#skip-list class=hash-link aria-label="Skip List的直接連結" title="Skip List的直接連結">​</a></h2>
<p>Skip list 是一種基於 linked list 的資料結構，提供了類似於平衡樹的查找效率 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>O</mi><mo stretchy=false>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>O(\log n)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-0.25em></span><span class="mord mathnormal" style=margin-right:0.02778em>O</span><span class=mopen>(</span><span class=mop>lo<span style=margin-right:0.01389em>g</span></span><span class=mspace style=margin-right:0.1667em></span><span class="mord mathnormal">n</span><span class=mclose>)</span></span></span></span>，但實現起來更簡單。
它使用多層 linked list 來跳過一些節點，從而加快查找速度。</p>
<p>與 B+Tree 一樣，Skip list 以有序的方式儲存資料，不同的是在插入跟刪除的時候，Skip list 不需要進行分裂或合併節點，而是透過隨機選擇 (丟硬幣) 的方式來維持平衡。</p>
<p>Skip list 提供了三種操作，分別是插入、刪除和查找。</p>
<ul>
<li>查找：從最高層開始，只要下一個節點小於目標值就繼續往右走，不然的話就往下一層走，直到到達最底層為止。</li>
<li>插入：<!-- -->
<ul>
<li>首先需要隨機選擇一個層級，從最低即開始丟硬幣決定是否要在這一層插入，如果不是的話就向上移動一層直到最高層為止，確保每層的分布是對數級別的。</li>
<li>然後跟查找一樣，從最高層開始，找到每一層中正確的插入位置。</li>
<li>最後從最底層開始插入節點，直到目標層級。從下到上插入的原因是為了併發性，因為只有最底層的被連接好之後，這個節點才算是對外可見的，搭配 CAS 甚至可以做到無鎖的插入。</li>
</ul>
</li>
<li>刪除：<!-- -->
<ul>
<li>先找出所有要刪除的節點，接著做軟刪除，最後 GC 會定期清理這些軟刪除的節點。</li>
</ul>
</li>
</ul>
<figure class=image-modal-container><img src=/RulerChen-Website/img/cmu15-445/c08/image-9.webp alt="" width=100% class=image-modal-thumbnail style=cursor:pointer loading=lazy><figcaption class=image-modal-caption>Skip List</figcaption></figure>
<p>Skip list 的主要優點在於不需要做 rebalancing，這也就代表了鎖的開銷會相對較低，且如果不使用 reverse pointer 的話記憶體的用量也會相對較少。
缺點在於不利於硬碟快取，因為有不同層級的節點會分布在不同的記憶體位置，這樣會導致 cache miss 的機率增加，且如果沒有 reverse pointer 的話反向搜索會相對困難。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=trie>Trie<a href=#trie class=hash-link aria-label=Trie的直接連結 title=Trie的直接連結>​</a></h2>
<p>因為 B+Tree 不提供關於內部節點下方是否存在節點的資訊，所以要判斷一個鍵是否存在就必須遍歷到葉節點，這可能導致多次昂貴的磁碟 I/O (cache miss)。</p>
<p>字典樹是一種樹形的資料結構，它將鍵儲存為數字 (或字元)，並且每個節點代表一個數字的前綴。
這些數字可以是 ASCII 字元、Unicode 字元或其他類型的數字。
字典樹的每個節點都包含一個指向下一層節點的指針，這些指針可以用來快速地查找鍵是否存在，且複雜度與鍵的長度成正比。</p>
<p>跨度 (span) 是指一個數字所佔用的位元數，如果是二進位的話，則跨度為 2。
如果這個數字及其前綴存在於資料集合中，那麼在該數字處會儲存一個指向下一層節點的指針，否則就儲存 null。</p>
<figure class=image-modal-container><img src=/RulerChen-Website/img/cmu15-445/c08/image-10.webp alt="" width=100% class=image-modal-thumbnail style=cursor:pointer loading=lazy><figcaption class=image-modal-caption>Trie</figcaption></figure>
<p>在實際應用中，Trie 的節點可能會非常稀疏，或是單一的分支過於冗長，因此我們可以採用壓縮的方式來儲存 :</p>
<ul>
<li>水平壓縮 (Horizontal Compression) : 如果同一層級的 span 很大且很空，可以考慮改成使用 array 來儲存</li>
<li>垂直壓縮 (Vertical Compression) / 基數樹 (Radix Tree) : 如果只有一個單一的分支，可以考慮將這個分支直接合併到父節點中，這樣可以減少節點的數量，但這樣有可能造成錯誤，因此最後還是需要跟原本的 tuple 做比對。</li>
</ul>
<figure class=image-modal-container><img src=/RulerChen-Website/img/cmu15-445/c08/image-16.webp alt="" width=100% class=image-modal-thumbnail style=cursor:pointer loading=lazy><figcaption class=image-modal-caption>Normal -> Horizontal Compression -> Radix Tree</figcaption></figure>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=inverted-index>Inverted Index<a href=#inverted-index class=hash-link aria-label="Inverted Index的直接連結" title="Inverted Index的直接連結">​</a></h2>
<p>前面討論的資料結構主要適用於查找一個確切的值，它們不支援關鍵字搜尋。
舉例來說，如果我們想查詢所有包含 Taiwan 這個詞的維基百科文章，傳統索引就無法直接做到，這就是為什麼需要 Inverted Index 的原因。</p>
<p>倒排索引儲存的是詞 (terms) 到包含這些詞項的記錄 (records) 之間的映射。
這些包含詞的記錄列表被稱為 posting list，簡單來說，它就像一本書的索引，但不是按照頁碼順序排列詞語，而是按照關鍵字來查找包含該詞語的所有文檔或記錄。</p>
<figure class=image-modal-container><img src=/RulerChen-Website/img/cmu15-445/c08/image-11.webp alt="" width=100% class=image-modal-thumbnail style=cursor:pointer loading=lazy><figcaption class=image-modal-caption>Inverted Index</figcaption></figure>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=lucene>Lucene<a href=#lucene class=hash-link aria-label=Lucene的直接連結 title=Lucene的直接連結>​</a></h3>
<p>Lucene 是一個專門的倒排索引引擎，它儲存倒排索引的方式是使用一種類似於字典樹的資料結構，稱為有限狀態轉換器 (finite state transducer, FST)。
與字典樹直接儲存指向元組的指針不同，有限狀態轉換器在每條邊上儲存權重，當你沿著路徑遍歷到你正在尋找的鍵時，這些權重的滾動加總最終會給你這個詞項在映射中儲存的確切位置。
這使得 Lucene 能夠高效地從詞項映射到其 posting list。</p>
<p>在 Lucene 的詞項字典中 (這是儲存所有唯一詞項的部分)，由於它是不可變的且預先構建的，因此可以應用多種壓縮技術，例如 :</p>
<ul>
<li>差分壓縮 (delta compression): 儲存相鄰值之間的差異，而不是每個值的完整形式，從而減少儲存空間。</li>
<li>位元打包 (bit-packing): 根據實際數據的位元需求來儲存數據，而不是使用固定的字節數，這在數值範圍不大時能顯著節省空間。</li>
</ul>
<p>此外，Lucene 還支援預聚合 (pre-aggregation)，這可以加速基於詞項分組的聚合查詢。</p>
<figure class=image-modal-container><img src=/RulerChen-Website/img/cmu15-445/c08/image-12.webp alt="" width=100% class=image-modal-thumbnail style=cursor:pointer loading=lazy><figcaption class=image-modal-caption>Lucene Inverted Index</figcaption></figure>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=postgresql>PostgreSQL<a href=#postgresql class=hash-link aria-label=PostgreSQL的直接連結 title=PostgreSQL的直接連結>​</a></h3>
<p>PostgreSQL 的通用倒排索引 (Generalized Inverted Index, GIN) 使用 B+Tree 來構建字典。這個 B+Tree 葉節點的值 (即發布列表的儲存方式) 取決於發布列表的大小 :</p>
<ul>
<li>對於較小的 posting list，葉節點中直接儲存的是一個排序過的記錄 ID 列表。</li>
<li>對於較大的 posting list，PostgreSQL 會為這些發布列表額外構建獨立的 B+Tree 來儲存記錄 ID，以提高訪問效率。</li>
</ul>
<p>PostgreSQL 還使用一個單獨的 pending list 來避免頻繁的小規模增量更新。
當有新的更新時，它們會先被記錄在這個待處理列表中，然後累積起來，最終以批次插入的方式一次性應用到主字典中。</p>
<figure class=image-modal-container><img src=/RulerChen-Website/img/cmu15-445/c08/image-13.webp alt="" width=100% class=image-modal-thumbnail style=cursor:pointer loading=lazy><figcaption class=image-modal-caption>PostgreSQL GIN Inverted Index</figcaption></figure>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=vector-index>Vector Index<a href=#vector-index class=hash-link aria-label="Vector Index的直接連結" title="Vector Index的直接連結">​</a></h2>
<p>倒排索引雖然支援關鍵字搜尋，但它無法理解內容的語義意義，這代表要找到的關鍵字必須完整地包含在內容中。
舉例來說，如果一個應用程式想要搜尋與特定主題相關的記錄，比如 "關於俚語的嘻哈團體歌曲"，在這種情況下，我們就需要一種除了倒排索引之外的其他方法。
倒排索引只能找到包含 "俚語"、"嘻哈"、"團體"、"歌曲" 等詞的文檔，但它無法理解這些詞組合起來的整體概念或語義上的相關性。</p>
<p>LLM 以其能夠為文本生成 embedding 而聞名，這些嵌入本質上是浮點數的陣列。
如果兩個文本在語義上相似，它們的嵌入在幾何空間中也會彼此接近。
因此，專門用於最近鄰搜尋 (nearest-neighbor search, NN) 的向量索引就能夠幫助我們解決上述類型的查詢。</p>
<p>然而，與我們之前看到的傳統查詢不同，這種基於語義相似性的查詢沒有一個絕對正確的答案，結果往往是相關度最高的幾個選項。
此外，在找到最近鄰居之前或之後，通常還需要對數據進行額外的過濾 (例如分類等等)，以滿足更精確的業務需求。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=inverted-file>Inverted File<a href=#inverted-file class=hash-link aria-label="Inverted File的直接連結" title="Inverted File的直接連結">​</a></h3>
<p>倒排檔案方法透過聚類演算法 (clustering algorithm) 將高維向量劃分成較小的群組。
當進行最近鄰搜尋時，會使用相同的聚類演算法將查詢向量定位到一個或幾個相關的群組中。
然後，只在這些被定位到的群組內部查找所有向量，以找到最近的鄰居 (有時也需要檢查附近的群組，以防最佳鄰居位於群組邊界)。
一個典型的例子是 IVFFlat 演算法。</p>
<p>為了進一步提升查找速度，可以對索引執行預處理 (preprocessing) 和量化 (quantization)。這些技術可以降維或降低其精度，從而加快查找時間。</p>
<figure class=image-modal-container><img src=/RulerChen-Website/img/cmu15-445/c08/image-14.webp alt="" width=100% class=image-modal-thumbnail style=cursor:pointer loading=lazy><figcaption class=image-modal-caption>Inverted File</figcaption></figure>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=navigable-small-worlds>Navigable Small Worlds<a href=#navigable-small-worlds class=hash-link aria-label="Navigable Small Worlds的直接連結" title="Navigable Small Worlds的直接連結">​</a></h3>
<p>Navigable Small Worlds 是一種基於圖的近似最近鄰搜尋方法。
它構建一個表示向量之間鄰居關係的圖，圖中的每個節點 (node) 代表一個向量，而它的邊 (edges) 則連結到其 n 個最近的鄰居。</p>
<p>當進行最近鄰搜尋時，Navigable Small Worlds 利用這個圖，從一個定義好的入口點開始，透過 greedy algorithm 選擇那些能讓它更接近查詢向量的邊，來逐步導航。
兩個知名的實現例子是 FAISS 和 HNSWlib (Hierarchical Navigable Small Worlds)。</p>
<figure class=image-modal-container><img src=/RulerChen-Website/img/cmu15-445/c08/image-15.webp alt="" width=100% class=image-modal-thumbnail style=cursor:pointer loading=lazy><figcaption class=image-modal-caption>Navigable Small Worlds</figcaption></figure></div><div style=margin-top:32px></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-tags-row"><div class=col><b>標籤：</b><ul class="tags_jXut padding--none margin-left--sm"><li class=tag_QGVx><a rel=tag class="tag_zVej tagRegular_sFm0" href=/RulerChen-Website/docs/tags/cmu-15-445/>CMU15-445</a></ul></div></div><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class=col><a href=https://github.com/RulerChen/RulerChen-Website/tree/main/docs/CMU15-445/c08.mdx target=_blank rel="noopener noreferrer" class=theme-edit-this-page><svg fill=currentColor height=20 width=20 viewBox="0 0 40 40" class=iconEdit_Z9Sw aria-hidden=true><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"/></g></svg>編輯此頁</a></div><div class="col lastUpdated_JAkA"><span class=theme-last-updated>最後<!-- -->於 <b><time datetime=2025-09-10T14:45:10.000Z itemprop=dateModified>2025年9月10日</time></b> <!-- -->更新</span></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label=文件選項卡><a class="pagination-nav__link pagination-nav__link--prev" href=/RulerChen-Website/docs/CMU15-445/c07/><div class=pagination-nav__sublabel>上一頁</div><div class=pagination-nav__label>Hash Tables</div></a><a class="pagination-nav__link pagination-nav__link--next" href=/RulerChen-Website/docs/CMU15-445/c09/><div class=pagination-nav__sublabel>下一頁</div><div class=pagination-nav__label>Index Concurrency Control</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href=#b-tree class="table-of-contents__link toc-highlight">B-Tree</a><ul><li><a href=#b-tree-family class="table-of-contents__link toc-highlight">B-Tree Family</a><li><a href=#btree class="table-of-contents__link toc-highlight">B+Tree</a><li><a href=#btree-operations class="table-of-contents__link toc-highlight">B+Tree Operations</a><li><a href=#btree-vs-b-tree class="table-of-contents__link toc-highlight">B+Tree vs B-Tree</a><li><a href=#composite-indexes class="table-of-contents__link toc-highlight">Composite Indexes</a><li><a href=#duplicate-keys class="table-of-contents__link toc-highlight">Duplicate Keys</a><li><a href=#clustered-indexes class="table-of-contents__link toc-highlight">Clustered Indexes</a><li><a href=#index-scan-page-sorting class="table-of-contents__link toc-highlight">Index Scan Page Sorting</a></ul><li><a href=#btree-design-choices class="table-of-contents__link toc-highlight">B+Tree Design Choices</a><ul><li><a href=#node-size class="table-of-contents__link toc-highlight">Node Size</a><li><a href=#merge-threshold class="table-of-contents__link toc-highlight">Merge Threshold</a><li><a href=#variable-length-keys class="table-of-contents__link toc-highlight">Variable Length Keys</a><li><a href=#intra-node-search class="table-of-contents__link toc-highlight">Intra-Node Search</a></ul><li><a href=#b-tree-optimizations class="table-of-contents__link toc-highlight">B+ Tree Optimizations</a><ul><li><a href=#prefix-compression class="table-of-contents__link toc-highlight">Prefix Compression</a><li><a href=#deduplication class="table-of-contents__link toc-highlight">Deduplication</a><li><a href=#suffix-truncation class="table-of-contents__link toc-highlight">Suffix Truncation</a><li><a href=#pointer-swizzling class="table-of-contents__link toc-highlight">Pointer Swizzling</a><li><a href=#bulk-insert class="table-of-contents__link toc-highlight">Bulk Insert</a><li><a href=#write-optimized-b-tree class="table-of-contents__link toc-highlight">Write-Optimized B+ Tree</a></ul><li><a href=#bloom-filter class="table-of-contents__link toc-highlight">Bloom Filter</a><li><a href=#skip-list class="table-of-contents__link toc-highlight">Skip List</a><li><a href=#trie class="table-of-contents__link toc-highlight">Trie</a><li><a href=#inverted-index class="table-of-contents__link toc-highlight">Inverted Index</a><ul><li><a href=#lucene class="table-of-contents__link toc-highlight">Lucene</a><li><a href=#postgresql class="table-of-contents__link toc-highlight">PostgreSQL</a></ul><li><a href=#vector-index class="table-of-contents__link toc-highlight">Vector Index</a><ul><li><a href=#inverted-file class="table-of-contents__link toc-highlight">Inverted File</a><li><a href=#navigable-small-worlds class="table-of-contents__link toc-highlight">Navigable Small Worlds</a></ul></ul></div></div></div></div></main></div></div></div></div>