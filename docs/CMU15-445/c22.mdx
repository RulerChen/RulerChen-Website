---
title: 'Distributed OLTP Database Systems'
sidebar_position: '22'
description: CMU15-445/645 Distributed OLTP Database Systems
keywords: [CMU15-445/645, Distributed OLTP Database Systems, CMU15-445/645 筆記]
---

<head>
  <title>CMU 15-445/645 筆記 Distributed OLTP Database Systems</title>
</head>

在上節中，我們討論了去中心化的分散式資料庫系統，但仍然有很多細節沒有討論到，這節我們會討論一些分散式 OLTP 系統的細節，像是

- 如果其中有節點發生故障怎麼處理
- 如果訊息在網路上延遲怎麼處理
- 是否需要所有節點都同意才能 commit 一個 transaction

我們要假設所有的節點都是可信任的，不然就需要採用 Byzantine Fault Tolerance 的方法 (blockchain)。

## Replication

DBMS 可以在多個節點上複製資料，這樣可以提高可用性，主要有兩種方式

![Replication](/img/cmu15-445/c22/image.png)

### Replication Configuration

#### Primary-Replica

所有關於寫的操作都會先寫到 primary node， primary node 更新完後再通知其他 replica node 更新，
而只讀的資料可以直接從 replica node 讀取，這樣可以提高效能。
如果 master 節點崩潰，則由共識算法選擇新的 master 節點。

#### Multi-Master

每個節點都可以更新資料，但節點之間需要透過 atomic commit protocol 來確保一致性。

### K-safety

K-safety 是用來衡量複製資料庫的容錯能力的閾值。
K 值表示每個數據物件必須始終可用的副本數量。
如果副本數量低於這個閾值，DBMS 會停止執行並將系統下線。K 值越高，數據丟失的風險就越低。

### Propagation Scheme

當交易在複製資料庫上提交時，DBMS 會決定是否需要等待該交易的更改傳播到其他節點後再向應用程式客戶端發送確認。
主要有兩種方式

#### Synchronous Propagation

主節點將更新發送到從節點，並等待它們確認已完全應用更改後，再通知客戶端更新成功。
這確保了強一致性，不會丟失任何數據，通常在傳統的 DBMS 中使用。

#### Asynchronous Propagation

主節點立即向客戶端返回確認，而不等待從節點應用更改。
這可能會導致讀取過期數據，但如果可以容忍某些數據丟失，這種方式是一種有效的優化，通常在 NoSQL 系統中使用。

### Propagation Timing

主節點甚麼時候將更新發送到從節點的策略。
主要有兩種方式

- Continuous Propagation : DBMS 生成日誌消息後立即發送。這包括提交和中止消息，這是大多數系統使用的方式。
- On Commit Propagation : DBMS 只有在交易提交後才將該交易的日誌消息發送到從節點。
  這避免了為已中止的交易傳送日誌記錄的浪費，並假設交易的日誌記錄能完全保存在內存中。

### Active vs Passive

根據如何將更改應用到從節點上，複製可以分為

- Active-Active : 交易在每個從節點上獨立執行，最後 DBMS 需要檢查每個節點上的結果是否一致，以確保交易正確提交，
  因為需要同步所有節點之間的交易順序，故較少使用。
- Active-Passive : 交易在一個單一節點上執行，然後將總體更改傳播到從節點。

## Atomic Commit Protocols

當一個跨多個節點的交易完成時，DBMS 需要詢問所有參與的節點是否可以安全地提交交易。
根據所使用的協議，不同數量的節點回應可能影響最終的提交結果。
常見的協議包括

- Two-Phase Commit (2PC)
- Three-Phase Commit (3PC)
- Paxos
- Raft
- Zookeeper Atomic Broadcast (ZAB)
- Viewstamped Replication

### Two-Phase Commit (2PC)

2PC 是一個經典的分散式交易提交協議，分為兩個階段

#### Prepare Phase

- 客戶端向協調者發送提交請求
- 協調者向參與節點發送 Prepare Message，詢問它們是否可以提交當前交易
- 如果某個參與者確認交易有效，它會回覆 OK 給協調者，如果任何參與者回覆中止，協調者則會向客戶端回覆中止

#### Commit Phase

- 如果協調者收到所有參與者的 OK，則進入提交階段。協調者向所有參與者發送提交消息，通知它們提交交易
- 當所有參與者回覆 OK 後，協調者會通知客戶端交易已成功提交。
- 如果交易在準備階段中止，協調者會向參與者發送中止消息，參與者應回覆 OK。
- 在故障情況下，所有節點會記錄每個階段的結果在非易失性日誌中，並在需要時阻塞，直到找到下一步的行動方案。
  如果協調者故障，參與者可以選擇安全地中止或嘗試在沒有協調者明確許可的情況下提交。

#### Optimization

- Early Prepare Voting : 如果 DBMS 發送的查詢已經是某個節點的最後執行查詢，該節點可以與查詢結果一起返回它對準備階段的投票
- Early Acknowledgement after Prepare : 如果所有節點都投票同意提交交易，協調者可以在提交階段完成前向客戶端發送成功確認

### Paxos

Paxos 是現代系統中比 2PC 更常用的共識協議。
Paxos 的協調者被稱為提議者 (Proposer)，參與者被稱為接受者 (Acceptor)。

- 客戶端向提議者發送提交請求 (Commit Request)
- 提議者向接受者發送提議消息 (Propose)
- 接受者如果尚未對較高邏輯時間戳的提議作出回應，則會發送同意 (Agree)，否則，發送拒絕 (Reject)
- 一旦大多數接受者發送同意，提議者會發送提交消息 (Commit)
- 提議者收到大多數接受者的確認後，向客戶端回覆提交成功

#### Multi-Paxos

如果系統內常有任意數量的 proposer，達成共識就會有點困難，
因此我們可以先透過 Paxos 選出一個主要的提議者，然後由主要提議者來進行提議，
並在一段時間內提交交易不需要 propose 直接進行 commit。
達到一定時間之後再重新選舉主要提議者。

## Consistency Issues (CAP / PACELC)

### CAP

CAP 定理指出一個分散式系統無法同時滿足以下三個條件

- 一致性 (Consistency) : 一致性在此與線性一致性 (Linearizability) 同義。對所有節點上的操作來說，一旦寫入完成，所有後續的讀取應該返回該寫入的值或更晚的寫入值
- 可用性 (Availability) : 可用性指的是所有仍在運行的節點都能滿足所有請求的能力。即使部分節點故障，仍然能夠提供服務
- 分區容錯性 (Partition Tolerance) : 分區容錯性意味著即使系統中部分節點間的消息丟失，系統仍能正確運行

### PACELC

CAP 定理的現代版本是 PACELC 定理，這個定理進一步考慮了一致性和延遲之間的取捨。

- P (Partition)：在發生網絡分區時，系統必須在可用性 (A) 和一致性 (C) 之間做出選擇。
- EL (Else)：即使在系統運行正常且無網絡分區的情況下，也必須在延遲 (Latency, L) 和一致性 (Consistency, C) 之間做出選擇。

## Google Spanner

![Google Spanner](/img/cmu15-445/c22/image-1.png)

## References

- [CMU 15-445/645: Introduction to Database Systems](https://15445.courses.cs.cmu.edu/fall2023/)
- [CMU 15-445/645: Introduction to Database Systems Youtube 2023 Fall](https://www.youtube.com/watch?v=QRJs_57Pung&list=PLSE8ODhjZXjbj8BMuIrRcacnQh20hmY9g&index=23)
